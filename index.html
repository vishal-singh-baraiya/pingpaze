<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ching: Secure Messenger</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* Simple scrollbar styling for webkit browsers */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #bdbdbd; border-radius: 3px;}
        ::-webkit-scrollbar-thumb:hover { background: #a0a0a0; }

        .toast {
            visibility: hidden; min-width: 250px; background-color: #333; color: #fff; text-align: center;
            border-radius: 8px; padding: 16px; position: fixed; z-index: 51; left: 50%;
            transform: translateX(-50%); bottom: 30px; opacity: 0;
            transition: opacity 0.5s, visibility 0.5s;
        }
        .toast.show { visibility: visible; opacity: 1; }

        .chat-bg {
            background-color: #e5ddd5;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100' 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M25 10 C25 10, 25 20, 35 20 C45 20, 45 10, 45 10' fill='none' stroke='%23d4c5b2' stroke-width='1'/%3E%3Cpath d='M75 10 C75 10, 75 20, 85 20 C95 20, 95 10, 95 10' fill='none' stroke='%23d4c5b2' stroke-width='1'/%3E%3Cpath d='M25 60 C25 60, 25 70, 35 70 C45 70, 45 60, 45 60' fill='none' stroke='%23d4c5b2' stroke-width='1'/%3E%3Cpath d='M75 60 C75 60, 75 70, 85 70 C95 70, 95 60, 95 60' fill='none' stroke='%23d4c5b2' stroke-width='1'/%3E%3C/svg%3E");
        }
        
        .active-chat {
            background-color: #e2e8f0; /* bg-slate-200 */
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen">

    <div class="w-full max-w-7xl mx-auto bg-white rounded-lg shadow-2xl flex h-[95vh] min-h-[700px]">
        <!-- Left Panel: Chat List -->
        <div class="w-full md:w-[35%] lg:w-[30%] border-r border-gray-200 flex flex-col bg-slate-50 relative">
            <div class="flex-shrink-0 p-4 border-b border-gray-200 flex justify-between items-center bg-slate-100">
                <h1 class="text-xl font-bold text-teal-600">Secure Messenger</h1>
                <div class="flex items-center space-x-2">
                     <button id="settingsBtn" title="Settings" class="text-gray-500 hover:text-gray-800 p-2 rounded-full hover:bg-gray-200">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                    </button>
                </div>
            </div>
            
            <div id="chatList" class="overflow-y-auto flex-grow p-2">
                <p class="text-sm text-gray-500 text-center p-4">No chats yet. Start a new one!</p>
            </div>

            <button id="newChatBtn" title="New Chat" class="absolute bottom-6 right-6 bg-teal-500 hover:bg-teal-600 text-white rounded-full p-4 shadow-lg transition-transform hover:scale-110">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg>
            </button>
        </div>

        <!-- Right Panel: Chat -->
        <div class="w-full md:w-[65%] lg:w-[70%] flex flex-col bg-slate-100 h-full">
            <div id="chat-header" class="flex items-center p-3 border-b border-gray-200 bg-slate-50 flex-shrink-0 min-h-[70px]">
                 <div class="w-10 h-10 rounded-full bg-gray-300 flex items-center justify-center mr-3">
                    <svg class="w-6 h-6 text-gray-500" id="chat-header-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                 </div>
                 <div>
                    <h2 id="chat-title" class="font-semibold text-gray-700">No Chat Active</h2>
                    <p id="status" class="text-xs text-gray-500">Status: Disconnected</p>
                 </div>
            </div>

            <div class="flex-grow overflow-y-auto p-4 md:p-6 chat-bg" id="chatBox">
                <div class="flex flex-col items-center justify-center h-full text-center text-gray-500">
                    <svg class="w-24 h-24 mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path></svg>
                    <h3 class="text-xl font-medium">Welcome to Secure Messenger</h3>
                    <p class="max-w-sm mt-2">Click the chat bubble button to start a new conversation. All messages are end-to-end encrypted and never stored on a server.</p>
                </div>
            </div>

            <div id="connectionPanel" class="p-4 bg-slate-50 border-t border-gray-200"></div>

            <div class="bg-slate-50 p-4 flex items-center flex-shrink-0 border-t border-gray-200">
                <form id="messageForm" class="flex items-center w-full space-x-3">
                    <input type="text" id="messageInput" class="flex-grow bg-white text-gray-800 rounded-full py-3 px-5 focus:outline-none focus:ring-2 focus:ring-teal-500 border border-gray-200" placeholder="Type a message..." disabled>
                    <button type="submit" id="sendBtn" class="bg-teal-500 text-white rounded-full p-3 hover:bg-teal-600 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors" disabled>
                         <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden items-center justify-center p-4">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
            <div class="flex justify-between items-center mb-4">
                 <h2 class="text-lg font-bold text-gray-800">Settings</h2>
                 <button id="closeSettingsBtn" class="text-gray-500 hover:text-gray-800">&times;</button>
            </div>
            <div class="bg-white p-4 rounded-lg border border-gray-200">
                <h2 class="font-semibold text-gray-800 mb-2">Your Identity</h2>
                <p class="text-xs text-gray-500 mb-3">Your secure keys are stored on this device. Share your public key to let others contact you.</p>
                <button id="generateKeysBtn" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-md transition-colors text-sm">
                    Generate / Load My Keys
                </button>
                <div class="mt-3">
                    <label for="myPublicKey" class="block text-xs font-medium text-gray-600">Your Public Key (Not needed for invites)</label>
                    <textarea id="myPublicKey" readonly rows="4" class="w-full mt-1 bg-gray-100 text-gray-600 rounded-md p-2 text-xs border border-gray-300 resize-none"></textarea>
                    <button id="copyMyKeyBtn" class="w-full mt-2 bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-1 px-3 text-sm rounded-md transition-colors">Copy Public Key</button>
                </div>
            </div>
        </div>
    </div>

    <div id="newChatModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden items-center justify-center p-4">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
             <div class="flex justify-between items-center mb-4">
                 <h2 class="text-lg font-bold text-gray-800">Start or Join a Chat</h2>
                 <button id="closeNewChatBtn" class="text-gray-500 hover:text-gray-800">&times;</button>
            </div>
            <div class="space-y-4">
                <button id="new1on1InviteBtn" class="w-full text-left p-3 bg-blue-500 hover:bg-blue-600 text-white rounded-md font-semibold">Start New 1-on-1 Chat</button>
                <button id="newGroupBtn" class="w-full text-left p-3 bg-indigo-500 hover:bg-indigo-600 text-white rounded-md font-semibold">Create New Group</button>
                
                <div class="pt-4 border-t">
                    <label for="pasteInviteCode" class="block text-sm font-medium text-gray-700 mb-1">Have an invite code?</label>
                    <p class="text-xs text-gray-500 mb-2">Paste any invite code here to join a 1-on-1 chat or a group.</p>
                    <textarea id="pasteInviteCode" rows="4" class="w-full bg-white text-gray-700 rounded-md p-2 text-xs border border-gray-300" placeholder="Paste invite code..."></textarea>
                    <button id="joinWithCodeBtn" class="w-full mt-2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md text-sm">Join / Respond</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let db; let myKeyPair = null; let currentMode = null; let peerConnection;
            let dataChannel; let sharedSecretKey = null; let isHost = false; let groupKey = null;
            let hostConnection = { pc: null, dc: null }; let groupPeers = new Map();
            let activeChatId = null;

            // --- UI Elements ---
            const myPublicKeyText = document.getElementById('myPublicKey');
            const statusEl = document.getElementById('status');
            const chatBox = document.getElementById('chatBox');
            const messageForm = document.getElementById('messageForm');
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            const toastEl = document.getElementById('toast');
            const chatTitle = document.getElementById('chat-title');
            const connectionPanel = document.getElementById('connectionPanel');
            const settingsModal = document.getElementById('settingsModal');
            const newChatModal = document.getElementById('newChatModal');

            // --- Core Functions (Crypto, DB) ---
            function initDB() {
                const request = indexedDB.open('secureChatDB_v7', 1); // Bumped DB version
                request.onerror = (e) => console.error("DB error:", e.target.errorCode);
                request.onsuccess = (e) => {
                    db = e.target.result;
                    loadMyKeys();
                    renderChatList();
                };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('keyStore')) db.createObjectStore('keyStore', { keyPath: 'name' });
                    if (!db.objectStoreNames.contains('contacts')) db.createObjectStore('contacts', { keyPath: 'id', autoIncrement: true });
                    if (!db.objectStoreNames.contains('groups')) db.createObjectStore('groups', { keyPath: 'id', autoIncrement: true });
                };
            }

            async function generateAndStoreKeys() {
                try {
                    myKeyPair = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey']);
                    const [publicKeyJwk, privateKeyJwk] = await Promise.all([
                        crypto.subtle.exportKey('jwk', myKeyPair.publicKey),
                        crypto.subtle.exportKey('jwk', myKeyPair.privateKey)
                    ]);
                    myPublicKeyText.value = JSON.stringify(publicKeyJwk, null, 2);
                    const tx = db.transaction('keyStore', 'readwrite');
                    tx.objectStore('keyStore').put({ name: 'myKeyPair', value: { publicKey: publicKeyJwk, privateKey: privateKeyJwk } });
                    tx.oncomplete = () => showToast('New keys generated and saved!');
                } catch (error) { console.error('Key generation failed:', error); showToast('Error: Key generation failed.', 'error'); }
            }
            
            async function loadMyKeys() {
                if (!db) return;
                const request = db.transaction('keyStore').objectStore('keyStore').get('myKeyPair');
                request.onsuccess = async () => {
                    if (request.result) {
                        const { publicKey, privateKey } = request.result.value;
                        myKeyPair = {
                            publicKey: await crypto.subtle.importKey('jwk', publicKey, { name: 'ECDH', namedCurve: 'P-256' }, true, []),
                            privateKey: await crypto.subtle.importKey('jwk', privateKey, { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey'])
                        };
                        myPublicKeyText.value = JSON.stringify(publicKey, null, 2);
                        showToast('Your keys were loaded from this device.');
                    } else { await generateAndStoreKeys(); }
                };
                 request.onerror = (e) => console.error("Failed to load keys", e);
            }

            async function deriveSharedSecret(peerPublicKeyJwk) {
                try {
                    const peerPublicKey = await crypto.subtle.importKey('jwk', peerPublicKeyJwk, { name: 'ECDH', namedCurve: 'P-256' }, true, []);
                    return await crypto.subtle.deriveKey({ name: 'ECDH', public: peerPublicKey }, myKeyPair.privateKey, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
                } catch (error) { console.error("Failed to derive secret:", error); showToast("Error deriving secret. Invalid peer key?", 'error'); return null; }
            }

            async function encrypt(data, key) {
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encoded = new TextEncoder().encode(JSON.stringify(data));
                const encryptedContent = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, encoded);
                const buffer = new Uint8Array(iv.length + encryptedContent.byteLength);
                buffer.set(iv);
                buffer.set(new Uint8Array(encryptedContent), iv.length);
                return buffer;
            }

            async function decrypt(buffer, key) {
                try {
                    const data = new Uint8Array(buffer);
                    const iv = data.slice(0, 12);
                    const content = data.slice(12);
                    const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, content);
                    return JSON.parse(new TextDecoder().decode(decrypted));
                } catch (e) { console.error("Decryption failed:", e); showToast("Error: Received a corrupted message.", 'error'); return null; }
            }
            
            async function renderChatList() {
                if(!db) return;
                const getStoreData = (storeName) => new Promise((resolve, reject) => {
                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                const [contacts, groups] = await Promise.all([getStoreData('contacts'), getStoreData('groups')]);

                const chatList = [
                    ...contacts.map(c => ({...c, type: 'contact'})),
                    ...groups.map(g => ({...g, type: 'group'}))
                ].sort((a, b) => a.name.localeCompare(b.name));

                const chatListEl = document.getElementById('chatList');
                chatListEl.innerHTML = '';
                if (chatList.length === 0) {
                    chatListEl.innerHTML = '<p class="text-sm text-gray-500 text-center p-4">No chats yet. Start a new one!</p>';
                    return;
                }

                chatList.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `flex items-center justify-between p-3 rounded-lg hover:bg-slate-100 cursor-pointer`;
                    const itemInfo = document.createElement('div');
                    itemInfo.className = 'flex items-center overflow-hidden';
                    const icon = item.type === 'contact'
                        ? `<svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>`
                        : `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>`;
                    
                    itemInfo.innerHTML = `
                        <div class="w-10 h-10 rounded-full ${item.type === 'contact' ? 'bg-gray-300' : 'bg-blue-200'} flex items-center justify-center mr-3 flex-shrink-0">
                           ${icon}
                        </div>
                        <span class="font-medium text-sm text-gray-700 truncate">${item.name.replace(/</g, "&lt;")}</span>`;
                    
                    itemDiv.onclick = () => {
                        document.querySelectorAll('#chatList > div').forEach(el => el.classList.remove('active-chat'));
                        itemDiv.classList.add('active-chat');
                        if (item.type === 'contact') showReconnectingUI(item);
                        else if (item.type === 'group' && item.isHost) startHostingSavedGroup(item);
                        else if (item.type === 'group' && !item.isHost) rejoinSavedGroup(item);
                    };

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'text-red-500 hover:text-red-700 p-1 rounded-full flex-shrink-0 ml-2 opacity-0 group-hover:opacity-100 transition-opacity';
                    deleteBtn.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>`;
                    deleteBtn.onclick = (e) => { 
                        e.stopPropagation();
                        if (confirm(`Are you sure you want to delete ${item.name}? This cannot be undone.`)) {
                             const storeName = item.type === 'contact' ? 'contacts' : 'groups';
                             deleteDBItem(storeName, item.id);
                        }
                    };

                    itemDiv.classList.add('group');
                    itemDiv.appendChild(itemInfo);
                    itemDiv.appendChild(deleteBtn);
                    chatListEl.appendChild(itemDiv);
                });
            }

            function saveDBItem(storeName, item) {
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.add(item);
                    request.onsuccess = () => { showToast(`${storeName.slice(0, -1)} saved!`); renderChatList(); resolve(request.result); };
                    request.onerror = (e) => { showToast(`Error saving ${storeName.slice(0, -1)}.`, 'error'); reject(e); };
                });
            }

            function deleteDBItem(storeName, id) {
                const transaction = db.transaction([storeName], 'readwrite');
                transaction.objectStore(storeName).delete(id);
                transaction.oncomplete = () => { showToast(`${storeName.slice(0, -1)} deleted.`); renderChatList(); if(activeChatId === id) resetState(); };
            }

            // --- UI & State Management ---
            function resetState(isSwitchingChat = false) {
                 if (peerConnection) { try { peerConnection.close(); } catch(e){} }
                 if (hostConnection.pc) { try { hostConnection.pc.close(); } catch(e){} }
                 groupPeers.forEach(peer => { try { peer.pc.close(); } catch(e){} });
                 peerConnection = null; dataChannel = null; sharedSecretKey = null;
                 isHost = false; groupKey = null; hostConnection = { pc: null, dc: null };
                 groupPeers.clear(); currentMode = null;
                 updateStatus('Disconnected');
                 connectionPanel.innerHTML = '';
                 if (!isSwitchingChat) {
                    activeChatId = null;
                    document.querySelectorAll('#chatList > div').forEach(el => el.classList.remove('active-chat'));
                    chatTitle.textContent = "No Chat Active";
                    chatBox.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-center text-gray-500"><svg class="w-24 h-24 mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path></svg><h3 class="text-xl font-medium">Welcome</h3><p>Click the chat bubble button to start a new conversation.</p></div>`;
                 }
            }

            function updateStatus(status) {
                const statusText = status.charAt(0).toUpperCase() + status.slice(1);
                 switch(status) {
                    case 'connected': statusEl.textContent = `Status: ${statusText}`; statusEl.className = 'text-xs text-green-500'; messageInput.disabled = false; sendBtn.disabled = false; connectionPanel.innerHTML = ''; if(chatBox.children[0]?.classList.contains('text-center')) chatBox.innerHTML = ''; displayMessage({ text: "You are now connected securely." }, "System"); break;
                    case 'connecting': statusEl.textContent = `Status: ${statusText}`; statusEl.className = 'text-xs text-yellow-500'; break;
                    default: statusEl.textContent = `Status: ${statusText}`; statusEl.className = 'text-xs text-red-500'; messageInput.disabled = true; sendBtn.disabled = true; break;
                 }
            }
            
            function displayMessage(msg, sender) {
                const msgDiv = document.createElement('div');
                let content = '', alignment = '';
                if (sender === 'System') { content = msg.text; alignment = 'bg-yellow-100 text-yellow-800 text-sm p-2 rounded-md my-2 mx-auto shadow-sm max-w-md text-center'; }
                else if (sender === 'Me') { content = msg.text.replace(/</g, "&lt;").replace(/>/g, "&gt;"); alignment = 'bg-emerald-200 p-3 rounded-lg rounded-br-none max-w-sm md:max-w-md my-1 ml-auto shadow'; }
                else {
                    let senderName = '';
                    if (currentMode === 'group' && isHost) senderName = `<strong>${(groupPeers.get(msg.senderId)?.name || 'Peer').replace(/</g, "&lt;")}</strong><br>`;
                    content = `${senderName}${msg.text.replace(/</g, "&lt;").replace(/>/g, "&gt;")}`;
                    alignment = 'bg-white p-3 rounded-lg rounded-bl-none max-w-sm md:max-w-md my-1 mr-auto shadow';
                }
                msgDiv.innerHTML = content; msgDiv.className = `break-words ${alignment}`; chatBox.appendChild(msgDiv); chatBox.scrollTop = chatBox.scrollHeight;
            }

            // --- WebRTC Connection ---
            function createPeerConnectionBase() { 
                const iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    {
                        urls: "turn:global.turn.twilio.com:3478",
                        username: "7b79f82662c382e8d3567a423528ce33a0058b8f2d65d4484050a491a134e195",
                        credential: "iO8g3/fT+efrC3w2I/9j+i8pA3dAk5bE3/4+u2fL7/I="
                    },
                    {
                        urls: "turn:global.turn.twilio.com:3478?transport=tcp",
                        username: "7b79f82662c382e8d3567a423528ce33a0058b8f2d65d4484050a491a134e195",
                        credential: "iO8g3/fT+efrC3w2I/9j+i8pA3dAk5bE3/4+u2fL7/I="
                    }
                ];
                return new RTCPeerConnection({ iceServers }); 
            }

            // --- Unified Invite Code Logic ---
            function b64encode(str) { return btoa(unescape(encodeURIComponent(str))); }
            function b64decode(str) { return decodeURIComponent(escape(atob(str))); }
            
            async function generateInvite(type, payload, senderName = "Anonymous") {
                const myPublicJwk = JSON.parse(myPublicKeyText.value);
                const invite = { type, payload, senderKey: myPublicJwk, senderName: senderName };
                return b64encode(JSON.stringify(invite));
            }

            async function handlePastedCode() {
                const code = document.getElementById('pasteInviteCode').value.trim();
                if (!code) return showToast('Invite code is empty.', 'error');
                
                try {
                    const decoded = JSON.parse(b64decode(code));
                    newChatModal.classList.add('hidden');
                    document.getElementById('pasteInviteCode').value = '';

                    switch(decoded.type) {
                        case 'p2p-offer': await handleP2POffer(decoded); break;
                        case 'p2p-answer': await handleP2PAnswer(decoded); break;
                        case 'group-offer': await handleGroupOffer(decoded); break;
                        case 'group-answer': await handleGroupAnswer(decoded); break;
                        default: showToast('Unknown invite code format.', 'error');
                    }
                } catch (e) {
                    console.error("Invite processing error:", e);
                    showToast('Invalid or corrupted invite code.', 'error');
                }
            }

            // --- 1-on-1 Chat Flow ---
            async function startNew1on1Chat() {
                const myName = prompt("What is your name for this chat?");
                if (!myName) return; 
                
                if(!myKeyPair) return showToast('Keys not loaded.', 'error');
                resetState(true);
                currentMode = 'p2p';
                isHost = true;
                chatBox.innerHTML = '';
                chatTitle.textContent = 'New 1-on-1 Chat';
                
                peerConnection = createPeerConnectionBase();
                dataChannel = peerConnection.createDataChannel('chat');
                setupP2PDataChannel();
                
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                await new Promise(resolve => { if (peerConnection.iceGatheringState === 'complete') resolve(); else peerConnection.onicegatheringstatechange = () => { if(peerConnection.iceGatheringState === 'complete') resolve(); } });
                
                const inviteCode = await generateInvite('p2p-offer', peerConnection.localDescription, myName);

                newChatModal.classList.add('hidden');
                connectionPanel.innerHTML = `<div class="p-4 space-y-3 bg-slate-100 rounded-lg">
                    <h4 class="font-medium text-sm text-gray-700">Your Invite Code is Ready</h4>
                    <p class="text-xs text-gray-500 mb-2">Send this code to the person you want to chat with. Once they respond with their code, paste it in the "New Chat" menu.</p>
                    <textarea rows="4" class="w-full text-xs p-2 border rounded-md" readonly>${inviteCode}</textarea>
                    <button onclick="navigator.clipboard.writeText(this.previousElementSibling.value); showToast('Invite Code Copied!');" class="w-full mt-2 bg-gray-200 hover:bg-gray-300 font-bold py-2 px-3 rounded-md text-sm">Copy Code</button>
                </div>`;
            }
            
            async function handleP2POffer(offerInvite) {
                const contactName = offerInvite.senderName || 'New Contact';
                const myName = prompt(`You have a chat invite from ${contactName}. What is your name?`);
                if (!myName) return;

                resetState(true);
                currentMode = 'p2p';
                isHost = false;
                chatBox.innerHTML = '';
                chatTitle.textContent = `Connecting to ${contactName}...`;
                
                const newContact = { name: contactName, publicKey: JSON.stringify(offerInvite.senderKey) };
                activeChatId = await saveDBItem('contacts', newContact);
                
                sharedSecretKey = await deriveSharedSecret(offerInvite.senderKey);
                if(!sharedSecretKey) return;
                
                peerConnection = createPeerConnectionBase();
                peerConnection.ondatachannel = (e) => { dataChannel = e.channel; setupP2PDataChannel(); };
                
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offerInvite.payload));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                await new Promise(resolve => { if (peerConnection.iceGatheringState === 'complete') resolve(); else peerConnection.onicegatheringstatechange = () => { if(peerConnection.iceGatheringState === 'complete') resolve(); } });
                
                const answerCode = await generateInvite('p2p-answer', peerConnection.localDescription, myName);

                connectionPanel.innerHTML = `<div class="p-4 space-y-3 bg-slate-100 rounded-lg">
                    <h4 class="font-medium text-sm text-gray-700">Response Code Generated</h4>
                    <p class="text-xs text-gray-500 mb-2">Send this code back to ${contactName} to complete the connection.</p>
                    <textarea rows="4" class="w-full text-xs p-2 border rounded-md" readonly>${answerCode}</textarea>
                    <button onclick="navigator.clipboard.writeText(this.previousElementSibling.value); showToast('Response Code Copied!');" class="w-full mt-2 bg-gray-200 hover:bg-gray-300 font-bold py-2 px-3 rounded-md text-sm">Copy Response Code</button>
                </div>`;
            }
            
            async function handleP2PAnswer(answerInvite) {
                if (!isHost || currentMode !== 'p2p') return showToast('Not waiting for a P2P answer.', 'error');
                
                sharedSecretKey = await deriveSharedSecret(answerInvite.senderKey);
                if (!sharedSecretKey) return;

                const contactName = answerInvite.senderName || 'New Contact';

                await peerConnection.setRemoteDescription(new RTCSessionDescription(answerInvite.payload));
                const newContact = { name: contactName, publicKey: JSON.stringify(answerInvite.senderKey) };
                activeChatId = await saveDBItem('contacts', newContact);
                chatTitle.textContent = `Chat with ${contactName}`;
            }

            function setupP2PDataChannel() {
                dataChannel.onopen = () => {
                    updateStatus('connected');
                };
                dataChannel.onclose = () => updateStatus('disconnected');
                dataChannel.onmessage = async (e) => { const msg = await decrypt(e.data, sharedSecretKey); if (msg) displayMessage(msg, 'Peer'); };
            }

             function showReconnectingUI(contact) {
                resetState(true);
                chatTitle.textContent = `Chat with ${contact.name}`;
                chatBox.innerHTML = '';
                connectionPanel.innerHTML = `<div class="p-4 space-y-3">
                    <h3 class="font-semibold text-gray-800 text-sm">Reconnect with ${contact.name}</h3>
                    <p class="text-xs text-gray-500">To reconnect, one person must create a new invite and the other must paste it.</p>
                    <div class="flex space-x-3">
                        <button id="reconnect_create_invite" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-3 rounded-md text-sm">Create New Invite</button>
                        <button onclick="document.getElementById('newChatBtn').click();" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-md text-sm">Paste Invite</button>
                    </div>
                </div>`;
                document.getElementById('reconnect_create_invite').onclick = () => startNew1on1Chat(); // Re-uses the main invite logic
            }
            // --- Group Chat Flow ---
            async function createNewGroup() {
                const groupName = prompt("Enter a name for your new group:");
                if (!groupName) return;
                isHost = true; 
                groupKey = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']); 
                const groupKeyJwk = await crypto.subtle.exportKey('jwk', groupKey);
                await saveDBItem('groups', { name: groupName, isHost: true, groupKey: groupKeyJwk });
                showToast('Group created! Select it from the list to start hosting.');
                newChatModal.classList.add('hidden');
            }

            async function startHostingSavedGroup(group) {
                 resetState(true);
                 currentMode = 'group';
                 isHost = true;
                 groupKey = await crypto.subtle.importKey('jwk', group.groupKey, { name: 'AES-GCM' }, true, ['encrypt', 'decrypt']);
                 updateStatus('connected'); // Host is always 'connected' to themselves
                 statusEl.textContent = "Status: Hosting";
                 chatTitle.textContent = `Group: ${group.name} (Host)`;
                 chatBox.innerHTML = '';
                 displayMessage({ text: `Hosting group "${group.name}". Members can join by pasting your group invite.` }, "System");
                 connectionPanel.innerHTML = `<div class="p-4 space-y-3 bg-slate-100 rounded-lg">
                    <h3 class="font-semibold text-gray-800 text-sm">Waiting for Members</h3>
                    <p class="text-xs text-gray-500">To invite members, click "New Chat" and paste the code they send you.</p>
                </div>`;
            }

            async function handleGroupOffer(offerInvite){
                if (!isHost || currentMode !== 'group') return showToast('You must be hosting a group to accept members.', 'error');
                
                const tempSecret = await deriveSharedSecret(offerInvite.senderKey);
                if (!tempSecret) return;

                const pc = createPeerConnectionBase();
                const peerId = crypto.randomUUID();
                const peerName = `Peer-${Math.floor(1000 + Math.random() * 9000)}`;

                pc.ondatachannel = (e) => {
                    const dc = e.channel;
                    groupPeers.set(peerId, { pc, dc, name: peerName, tempSecret });
                    updateGroupMembersList();

                    dc.onopen = async () => {
                        showToast(`${peerName} has connected.`);
                        const groupKeyJwk = await crypto.subtle.exportKey('jwk', groupKey);
                        const encryptedKey = await encrypt({ type: 'groupKey', payload: {key: groupKeyJwk, name: chatTitle.textContent.split('(Host)')[0].replace('Group:','').trim() } }, tempSecret);
                        dc.send(encryptedKey);
                    };
                    dc.onmessage = async (event) => {
                        const decrypted = await decrypt(event.data, tempSecret);
                        if (!decrypted || decrypted.type !== 'chat') return;
                        const relayMsg = { senderId: peerId, senderName: peerName, text: decrypted.payload.text };
                        displayMessage(relayMsg, 'Peer');
                        const encryptedRelay = await encrypt(relayMsg, groupKey);
                        groupPeers.forEach((peer, id) => {
                            if (id !== peerId && peer.dc.readyState === 'open') {
                                peer.dc.send(JSON.stringify({ type: 'groupChat', payload: encryptedRelay }));
                            }
                        });
                    };
                    dc.onclose = () => {
                        showToast(`${peerName} disconnected.`);
                        groupPeers.delete(peerId);
                        updateGroupMembersList();
                    };
                };

                await pc.setRemoteDescription(new RTCSessionDescription(offerInvite.payload));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                await new Promise(resolve => { if (peerConnection.iceGatheringState === 'complete') resolve(); else pc.onicegatheringstatechange = () => { if(pc.iceGatheringState === 'complete') resolve(); } });
                
                const answerCode = await generateInvite('group-answer', pc.localDescription);
                // Show the answer code in a modal or panel for the host to copy
                connectionPanel.innerHTML += `<div class="mt-4 p-4 space-y-3 bg-green-100 rounded-lg">
                    <h4 class="font-medium text-sm text-gray-700">Response for New Member</h4>
                    <p class="text-xs text-gray-500 mb-2">Send this code back to the joining member.</p>
                    <textarea rows="4" class="w-full text-xs p-2 border rounded-md" readonly>${answerCode}</textarea>
                    <button onclick="navigator.clipboard.writeText(this.previousElementSibling.value); showToast('Response Code Copied!'); this.parentElement.remove();" class="w-full mt-2 bg-gray-200 hover:bg-gray-300 font-bold py-2 px-3 rounded-md text-sm">Copy & Dismiss</button>
                </div>`;
            }

            async function rejoinSavedGroup(group) {
                resetState(true);
                currentMode = 'group';
                isHost = false;
                chatTitle.textContent = `Reconnecting to ${group.name}...`;
                chatBox.innerHTML = '';

                // This part is the same as starting a new group join, just with pre-filled host key
                 hostConnection.hostPublicKey = JSON.parse(group.hostPublicKey);
                 const tempSecret = await deriveSharedSecret(hostConnection.hostPublicKey);
                 if (!tempSecret) return;
                 hostConnection.tempSecret = tempSecret;

                 const pc = createPeerConnectionBase();
                 hostConnection.pc = pc;
                 hostConnection.dc = pc.createDataChannel('chat');
                 setupGroupClientDataChannel(false, group.name);

                 const offer = await pc.createOffer();
                 await pc.setLocalDescription(offer);
                 await new Promise(resolve => { if (pc.iceGatheringState === 'complete') resolve(); else pc.onicegatheringstatechange = () => { if(pc.iceGatheringState === 'complete') resolve(); } });
                
                 const offerCode = await generateInvite('group-offer', pc.localDescription);
                 connectionPanel.innerHTML = `<div class="p-4 space-y-3 bg-slate-100 rounded-lg">
                    <h4 class="font-medium text-sm text-gray-700">Re-join Invite Code</h4>
                    <p class="text-xs text-gray-500 mb-2">Send this code to the group host. Once they respond, paste their code in the "New Chat" menu.</p>
                    <textarea rows="4" class="w-full text-xs p-2 border rounded-md" readonly>${offerCode}</textarea>
                    <button onclick="navigator.clipboard.writeText(this.previousElementSibling.value); showToast('Invite Code Copied!');" class="w-full mt-2 bg-gray-200 hover:bg-gray-300 font-bold py-2 px-3 rounded-md text-sm">Copy Re-join Code</button>
                </div>`;
            }

            async function handleGroupAnswer(answerInvite) {
                if(isHost || currentMode !== 'group') return showToast('Not waiting for a group answer.', 'error');
                await hostConnection.pc.setRemoteDescription(new RTCSessionDescription(answerInvite.payload));
            }

            function setupGroupClientDataChannel(isNewJoin, groupName) {
                hostConnection.dc.onopen = () => updateStatus('connected');
                hostConnection.dc.onmessage = async (e) => {
                    if (e.data instanceof ArrayBuffer) { // Group key exchange
                        const decrypted = await decrypt(e.data, hostConnection.tempSecret);
                        if(decrypted && decrypted.type === 'groupKey') { 
                            groupKey = await crypto.subtle.importKey('jwk', decrypted.payload.key, { name: 'AES-GCM' }, true, ['encrypt', 'decrypt']);
                            displayMessage({ text: "Secure group channel established!" }, "System");
                            chatTitle.textContent = `Group: ${decrypted.payload.name}`;
                            if (isNewJoin) {
                                saveDBItem('groups', {name: decrypted.payload.name, isHost: false, groupKey: decrypted.payload.key, hostPublicKey: JSON.stringify(hostConnection.hostPublicKey) });
                            }
                        }
                    } else { // Relayed chat message
                        const msg = JSON.parse(e.data); 
                        if (msg.type === 'groupChat') { 
                            const decrypted = await decrypt(msg.payload, groupKey); 
                            if (decrypted) displayMessage(decrypted, 'Peer'); 
                        }
                    }
                };
                hostConnection.dc.onclose = () => updateStatus('disconnected');
            }
            function updateGroupMembersList() { const count = groupPeers.size + 1; chatTitle.textContent = `${chatTitle.textContent.split('-')[0].trim()} - ${count} Member${count > 1 ? 's' : ''}`; }


            // --- Main Message Sender ---
            messageForm.addEventListener('submit', async (e) => {
                e.preventDefault(); const text = messageInput.value.trim(); if (!text) return; const msg = { text }; displayMessage(msg, 'Me');
                if (currentMode === 'p2p' && dataChannel?.readyState === 'open') { const encrypted = await encrypt(msg, sharedSecretKey); dataChannel.send(encrypted); }
                else if (currentMode === 'group') {
                    if (isHost && groupKey) { 
                        const encryptedRelay = await encrypt({ senderName: 'Host', text }, groupKey); 
                        groupPeers.forEach(peer => { if(peer.dc.readyState === 'open') peer.dc.send(JSON.stringify({ type: 'groupChat', payload: encryptedRelay })); }); 
                    }
                    else if (!isHost && hostConnection.dc?.readyState === 'open') { 
                        const encrypted = await encrypt({ type: 'chat', payload: msg }, hostConnection.tempSecret); 
                        hostConnection.dc.send(encrypted); 
                    }
                }
                messageInput.value = '';
            });

            // --- Global Event Listeners & Init ---
            document.getElementById('generateKeysBtn').onclick = generateAndStoreKeys;
            document.getElementById('copyMyKeyBtn').onclick = () => { myPublicKeyText.select(); document.execCommand('copy'); showToast('Public key copied!'); };
            
            // Modal Toggles & Actions
            document.getElementById('settingsBtn').onclick = () => settingsModal.classList.remove('hidden');
            document.getElementById('closeSettingsBtn').onclick = () => settingsModal.classList.add('hidden');
            document.getElementById('newChatBtn').onclick = () => newChatModal.classList.remove('hidden');
            document.getElementById('closeNewChatBtn').onclick = () => newChatModal.classList.add('hidden');
            
            document.getElementById('new1on1InviteBtn').onclick = startNew1on1Chat;
            document.getElementById('newGroupBtn').onclick = createNewGroup;
            document.getElementById('joinWithCodeBtn').onclick = handlePastedCode;

            window.showToast = (message, type = 'info') => { toastEl.textContent = message; toastEl.className = `toast show ${type === 'error' ? 'bg-red-600' : 'bg-gray-700'}`; setTimeout(() => { toastEl.className = 'toast'; }, 3000); };
            
            initDB();
        });
    </script>
</body>
</html>

